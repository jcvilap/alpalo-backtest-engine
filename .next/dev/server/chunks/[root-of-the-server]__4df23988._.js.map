{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 58, "column": 0}, "map": {"version":3,"sources":["file:///Users/jvila/WebstormProjects/alpalo-v2/src/lib/polygon/client.ts"],"sourcesContent":["import { OHLC } from '../types';\nimport fs from 'fs';\nimport path from 'path';\n\n\nconst BASE_URL = 'https://api.polygon.io/v2/aggs/ticker';\nconst CACHE_DIR = path.join(process.cwd(), 'cache');\n\nexport class PolygonClient {\n    constructor() {\n        if (!fs.existsSync(CACHE_DIR)) {\n            fs.mkdirSync(CACHE_DIR, { recursive: true });\n        }\n    }\n\n    private getCacheFilePath(ticker: string): string {\n        return path.join(CACHE_DIR, `${ticker}.json`);\n    }\n\n    private loadCache(ticker: string): OHLC[] {\n        const filePath = this.getCacheFilePath(ticker);\n        if (fs.existsSync(filePath)) {\n            try {\n                const data = fs.readFileSync(filePath, 'utf-8');\n                return JSON.parse(data);\n            } catch (e) {\n                console.error(`Error reading cache for ${ticker}:`, e);\n                return [];\n            }\n        }\n        return [];\n    }\n\n    private saveCache(ticker: string, data: OHLC[]) {\n        const filePath = this.getCacheFilePath(ticker);\n        // Sort by date and deduplicate\n        const uniqueData = Array.from(new Map(data.map(item => [item.date, item])).values())\n            .sort((a, b) => new Date(a.date).getTime() - new Date(b.date).getTime());\n\n        fs.writeFileSync(filePath, JSON.stringify(uniqueData, null, 2));\n    }\n\n    async fetchAggregates(ticker: string, from: string, to: string): Promise<OHLC[]> {\n        const apiKey = process.env.POLYGON_API_KEY;\n        if (!apiKey) {\n            throw new Error('POLYGON_API_KEY is not set');\n        }\n\n        // 1. Load Cache\n        let cachedData = this.loadCache(ticker);\n\n        // 2. Check what we have\n        if (cachedData.length > 0) {\n            const cacheStart = cachedData[0].date;\n            const cacheEnd = cachedData[cachedData.length - 1].date;\n\n            const reqStart = new Date(from);\n            const reqEnd = new Date(to);\n            const cStart = new Date(cacheStart);\n            const cEnd = new Date(cacheEnd);\n\n            // If request is fully within cache, return cached slice\n            if (reqStart >= cStart && reqEnd <= cEnd) {\n                console.log(`[CACHE HIT] ${ticker}: ${from} to ${to}`);\n                return cachedData.filter(d => {\n                    const dDate = new Date(d.date);\n                    return dDate >= reqStart && dDate <= reqEnd;\n                });\n            }\n\n            // Identify missing ranges\n            const promises: Promise<OHLC[]>[] = [];\n\n            // Missing Head\n            if (reqStart < cStart) {\n                const headEnd = new Date(cStart);\n                headEnd.setDate(headEnd.getDate() - 1);\n                console.log(`[CACHE MISS HEAD] ${ticker}: ${from} to ${headEnd.toISOString().split('T')[0]}`);\n                promises.push(this.fetchFromApi(ticker, from, headEnd.toISOString().split('T')[0]));\n            }\n\n            // Missing Tail\n            if (reqEnd > cEnd) {\n                const tailStart = new Date(cEnd);\n                tailStart.setDate(tailStart.getDate() + 1);\n                console.log(`[CACHE MISS TAIL] ${ticker}: ${tailStart.toISOString().split('T')[0]} to ${to}`);\n                promises.push(this.fetchFromApi(ticker, tailStart.toISOString().split('T')[0], to));\n            }\n\n            if (promises.length > 0) {\n                try {\n                    const newSegments = await Promise.all(promises);\n                    const allNewData = newSegments.flat();\n                    cachedData = [...cachedData, ...allNewData];\n                    this.saveCache(ticker, cachedData);\n                } catch (error) {\n                    // If API fetch fails (e.g., Forbidden for old data), continue with cached data\n                    console.warn(`Failed to fetch additional data for ${ticker}:`, error instanceof Error ? error.message : error);\n                    // Don't throw - use cached data we have\n                }\n            }\n\n            // Return requested range from updated cache\n            return cachedData.filter(d => {\n                const dDate = new Date(d.date);\n                return dDate >= reqStart && dDate <= reqEnd;\n            });\n        } else {\n            // No cache - fetch from API\n            console.log(`[CACHE EMPTY] ${ticker}: Fetching fresh data`);\n            try {\n                const data = await this.fetchFromApi(ticker, from, to);\n                this.saveCache(ticker, data);\n                return data;\n            } catch (error) {\n                console.error(`Failed to fetch data for ${ticker}:`, error instanceof Error ? error.message : error);\n                return []; // Return empty array instead of throwing\n            }\n        }\n    }\n\n    private async fetchFromApi(ticker: string, from: string, to: string): Promise<OHLC[]> {\n        const apiKey = process.env.POLYGON_API_KEY;\n        // Polygon API errors if from > to (e.g. asking for a weekend gap or invalid range)\n        if (new Date(from) > new Date(to)) {\n            return [];\n        }\n\n        const url = `${BASE_URL}/${ticker}/range/1/day/${from}/${to}?adjusted=true&sort=asc&limit=50000&apiKey=${apiKey}`;\n\n        const response = await fetch(url);\n        if (!response.ok) {\n            // Handle 429 or other errors gracefully? For now throw.\n            throw new Error(`Failed to fetch data for ${ticker}: ${response.statusText}`);\n        }\n\n        const data = await response.json();\n\n        if (!data.results || data.results.length === 0) {\n            return [];\n        }\n\n        interface PolygonResult {\n            t: number;\n            o: number;\n            h: number;\n            l: number;\n            c: number;\n            v: number;\n        }\n\n        return data.results.map((res: PolygonResult) => ({\n            date: new Date(res.t).toISOString().split('T')[0],\n            open: res.o,\n            high: res.h,\n            low: res.l,\n            close: res.c,\n            volume: res.v\n        }));\n    }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 203, "column": 0}, "map": {"version":3,"sources":["file:///Users/jvila/WebstormProjects/alpalo-v2/src/lib/strategy/indicators.ts"],"sourcesContent":["import { OHLC } from '../types';\n\nexport class Indicators {\n    static simpleMovingAverage(data: OHLC[], period: number): number[] {\n        if (data.length < period) {\n            return [];\n        }\n\n        const sma: number[] = [];\n        for (let i = period - 1; i < data.length; i++) {\n            const sum = data.slice(i - period + 1, i + 1).reduce((acc, candle) => acc + candle.close, 0);\n            sma.push(sum / period);\n        }\n        return sma;\n    }\n\n    static rateOfChange(data: OHLC[], period: number): number[] {\n        if (data.length < period) {\n            return [];\n        }\n\n        const roc: number[] = [];\n        for (let i = period; i < data.length; i++) {\n            const current = data[i].close;\n            const prev = data[i - period].close;\n            roc.push(((current - prev) / prev) * 100);\n        }\n        return roc;\n    }\n}\n"],"names":[],"mappings":";;;;AAEO,MAAM;IACT,OAAO,oBAAoB,IAAY,EAAE,MAAc,EAAY;QAC/D,IAAI,KAAK,MAAM,GAAG,QAAQ;YACtB,OAAO,EAAE;QACb;QAEA,MAAM,MAAgB,EAAE;QACxB,IAAK,IAAI,IAAI,SAAS,GAAG,IAAI,KAAK,MAAM,EAAE,IAAK;YAC3C,MAAM,MAAM,KAAK,KAAK,CAAC,IAAI,SAAS,GAAG,IAAI,GAAG,MAAM,CAAC,CAAC,KAAK,SAAW,MAAM,OAAO,KAAK,EAAE;YAC1F,IAAI,IAAI,CAAC,MAAM;QACnB;QACA,OAAO;IACX;IAEA,OAAO,aAAa,IAAY,EAAE,MAAc,EAAY;QACxD,IAAI,KAAK,MAAM,GAAG,QAAQ;YACtB,OAAO,EAAE;QACb;QAEA,MAAM,MAAgB,EAAE;QACxB,IAAK,IAAI,IAAI,QAAQ,IAAI,KAAK,MAAM,EAAE,IAAK;YACvC,MAAM,UAAU,IAAI,CAAC,EAAE,CAAC,KAAK;YAC7B,MAAM,OAAO,IAAI,CAAC,IAAI,OAAO,CAAC,KAAK;YACnC,IAAI,IAAI,CAAC,AAAC,CAAC,UAAU,IAAI,IAAI,OAAQ;QACzC;QACA,OAAO;IACX;AACJ"}},
    {"offset": {"line": 236, "column": 0}, "map": {"version":3,"sources":["file:///Users/jvila/WebstormProjects/alpalo-v2/src/lib/strategy/trendFollowingStrategy.ts"],"sourcesContent":["import { Strategy, StrategySignal, OHLC } from '../types';\nimport { Indicators } from './indicators';\n\nexport class TrendFollowingStrategy implements Strategy {\n    name = 'TrendFollowing';\n\n    analyze(data: OHLC[]): StrategySignal {\n        if (data.length < 250) {\n            return { symbol: 'TQQQ', action: 'HOLD', weight: 0, reason: 'Insufficient data' };\n        }\n\n        const ma250 = Indicators.simpleMovingAverage(data, 250);\n        const currentPrice = data[data.length - 1].close;\n        const currentMA250 = ma250[ma250.length - 1];\n\n        if (currentPrice > currentMA250) {\n            return {\n                symbol: 'TQQQ',\n                action: 'BUY',\n                weight: 1.0,\n                reason: `Price (${currentPrice.toFixed(2)}) > MA250 (${currentMA250.toFixed(2)})`\n            };\n        } else {\n            return {\n                symbol: 'SQQQ',\n                action: 'BUY',\n                weight: 1.0,\n                reason: `Price (${currentPrice.toFixed(2)}) < MA250 (${currentMA250.toFixed(2)})`\n            };\n        }\n    }\n}\n"],"names":[],"mappings":";;;;AACA;;AAEO,MAAM;IACT,OAAO,iBAAiB;IAExB,QAAQ,IAAY,EAAkB;QAClC,IAAI,KAAK,MAAM,GAAG,KAAK;YACnB,OAAO;gBAAE,QAAQ;gBAAQ,QAAQ;gBAAQ,QAAQ;gBAAG,QAAQ;YAAoB;QACpF;QAEA,MAAM,QAAQ,wLAAU,CAAC,mBAAmB,CAAC,MAAM;QACnD,MAAM,eAAe,IAAI,CAAC,KAAK,MAAM,GAAG,EAAE,CAAC,KAAK;QAChD,MAAM,eAAe,KAAK,CAAC,MAAM,MAAM,GAAG,EAAE;QAE5C,IAAI,eAAe,cAAc;YAC7B,OAAO;gBACH,QAAQ;gBACR,QAAQ;gBACR,QAAQ;gBACR,QAAQ,CAAC,OAAO,EAAE,aAAa,OAAO,CAAC,GAAG,WAAW,EAAE,aAAa,OAAO,CAAC,GAAG,CAAC,CAAC;YACrF;QACJ,OAAO;YACH,OAAO;gBACH,QAAQ;gBACR,QAAQ;gBACR,QAAQ;gBACR,QAAQ,CAAC,OAAO,EAAE,aAAa,OAAO,CAAC,GAAG,WAAW,EAAE,aAAa,OAAO,CAAC,GAAG,CAAC,CAAC;YACrF;QACJ;IACJ;AACJ"}},
    {"offset": {"line": 277, "column": 0}, "map": {"version":3,"sources":["file:///Users/jvila/WebstormProjects/alpalo-v2/src/lib/strategy/meanReversionStrategy.ts"],"sourcesContent":["import { Strategy, StrategySignal, OHLC } from '../types';\nimport { Indicators } from './indicators';\n\nexport class MeanReversionStrategy implements Strategy {\n    name = 'MeanReversion';\n\n    analyze(data: OHLC[]): StrategySignal {\n        if (data.length < 20) {\n            return { symbol: 'TQQQ', action: 'HOLD', weight: 0, reason: 'Insufficient data' };\n        }\n\n        const roc10 = Indicators.rateOfChange(data, 10);\n        const currentROC = roc10[roc10.length - 1];\n\n        if (currentROC > 5) {\n            return {\n                symbol: 'SQQQ',\n                action: 'BUY',\n                weight: 0.5,\n                reason: `ROC (${currentROC.toFixed(2)}) > 5, potential reversal`\n            };\n        } else if (currentROC < -5) {\n            return {\n                symbol: 'TQQQ',\n                action: 'BUY',\n                weight: 0.5,\n                reason: `ROC (${currentROC.toFixed(2)}) < -5, potential bounce`\n            };\n        }\n\n        return { symbol: 'TQQQ', action: 'HOLD', weight: 0, reason: 'Neutral ROC' };\n    }\n}\n"],"names":[],"mappings":";;;;AACA;;AAEO,MAAM;IACT,OAAO,gBAAgB;IAEvB,QAAQ,IAAY,EAAkB;QAClC,IAAI,KAAK,MAAM,GAAG,IAAI;YAClB,OAAO;gBAAE,QAAQ;gBAAQ,QAAQ;gBAAQ,QAAQ;gBAAG,QAAQ;YAAoB;QACpF;QAEA,MAAM,QAAQ,wLAAU,CAAC,YAAY,CAAC,MAAM;QAC5C,MAAM,aAAa,KAAK,CAAC,MAAM,MAAM,GAAG,EAAE;QAE1C,IAAI,aAAa,GAAG;YAChB,OAAO;gBACH,QAAQ;gBACR,QAAQ;gBACR,QAAQ;gBACR,QAAQ,CAAC,KAAK,EAAE,WAAW,OAAO,CAAC,GAAG,yBAAyB,CAAC;YACpE;QACJ,OAAO,IAAI,aAAa,CAAC,GAAG;YACxB,OAAO;gBACH,QAAQ;gBACR,QAAQ;gBACR,QAAQ;gBACR,QAAQ,CAAC,KAAK,EAAE,WAAW,OAAO,CAAC,GAAG,wBAAwB,CAAC;YACnE;QACJ;QAEA,OAAO;YAAE,QAAQ;YAAQ,QAAQ;YAAQ,QAAQ;YAAG,QAAQ;QAAc;IAC9E;AACJ"}},
    {"offset": {"line": 323, "column": 0}, "map": {"version":3,"sources":["file:///Users/jvila/WebstormProjects/alpalo-v2/src/lib/strategy/strategyController.ts"],"sourcesContent":["import { Strategy, StrategySignal, OHLC } from '../types';\nimport { TrendFollowingStrategy } from './trendFollowingStrategy';\nimport { MeanReversionStrategy } from './meanReversionStrategy';\n\nexport class StrategyController {\n    private strategies: Strategy[] = [];\n\n    constructor() {\n        this.strategies.push(new TrendFollowingStrategy());\n        this.strategies.push(new MeanReversionStrategy());\n    }\n\n    analyze(data: OHLC[]): StrategySignal {\n        const signals = this.strategies.map(s => s.analyze(data));\n        const trendSignal = signals.find(s => s.symbol === 'TQQQ' || s.symbol === 'SQQQ');\n\n        return trendSignal || { symbol: 'TQQQ', action: 'HOLD', weight: 0, reason: 'No signal' };\n    }\n}\n"],"names":[],"mappings":";;;;AACA;AACA;;;AAEO,MAAM;IACD,aAAyB,EAAE,CAAC;IAEpC,aAAc;QACV,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,gNAAsB;QAC/C,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,8MAAqB;IAClD;IAEA,QAAQ,IAAY,EAAkB;QAClC,MAAM,UAAU,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,CAAA,IAAK,EAAE,OAAO,CAAC;QACnD,MAAM,cAAc,QAAQ,IAAI,CAAC,CAAA,IAAK,EAAE,MAAM,KAAK,UAAU,EAAE,MAAM,KAAK;QAE1E,OAAO,eAAe;YAAE,QAAQ;YAAQ,QAAQ;YAAQ,QAAQ;YAAG,QAAQ;QAAY;IAC3F;AACJ"}},
    {"offset": {"line": 352, "column": 0}, "map": {"version":3,"sources":["file:///Users/jvila/WebstormProjects/alpalo-v2/src/lib/backtest/backtestEngine.ts"],"sourcesContent":["import { StrategyController } from '../strategy/strategyController';\nimport { OHLC } from '../types';\n\nexport interface Trade {\n    entryDate: string;\n    exitDate?: string;\n    symbol: string;\n    side: 'LONG' | 'SHORT';\n    entryPrice: number;\n    exitPrice?: number;\n    shares: number;\n    pnl?: number;\n    returnPct?: number;\n    daysHeld?: number;\n    positionSizePct?: number; // Percentage of portfolio allocated to this trade\n    portfolioReturnPct?: number; // Return contribution to the entire portfolio\n}\n\nexport interface BacktestResult {\n    trades: Trade[];\n    equityCurve: { date: string; equity: number; benchmark: number; benchmarkTQQQ: number }[];\n    metrics: {\n        totalReturn: number;\n        cagr: number;\n        maxDrawdown: number;\n        sharpeRatio: number;\n        avgTrades: {\n            daily: number;\n            monthly: number;\n            annually: number;\n        };\n        winRate: {\n            wins: number;\n            losses: number;\n            winPct: number;\n        };\n        avgPositionSize: number; // Average % of portfolio per trade\n        benchmark: {\n            totalReturn: number;\n            cagr: number;\n            maxDrawdown: number;\n            sharpeRatio: number;\n        };\n        benchmarkTQQQ: {\n            totalReturn: number;\n            cagr: number;\n            maxDrawdown: number;\n            sharpeRatio: number;\n        };\n    };\n}\n\nexport class BacktestEngine {\n    private strategyController: StrategyController;\n    private initialCapital: number;\n\n    constructor(initialCapital: number = 10000) {\n        this.strategyController = new StrategyController();\n        this.initialCapital = initialCapital;\n    }\n\n    run(qqqData: OHLC[], tqqqData: OHLC[], sqqqData: OHLC[]): BacktestResult {\n        let cash = this.initialCapital;\n        let shares = 0;\n        let currentPosition: Trade | null = null;\n        const trades: Trade[] = [];\n        const equityCurve: { date: string; equity: number; benchmark: number; benchmarkTQQQ: number }[] = [];\n\n        // Benchmark tracking (NDX)\n        const initialBenchmarkPrice = qqqData[0]?.close || 1;\n        const benchmarkShares = this.initialCapital / initialBenchmarkPrice;\n\n        // Benchmark tracking (TQQQ)\n        // We need to align TQQQ data with NDX data dates\n        const tqqqMap = new Map(tqqqData.map(d => [d.date, d]));\n        const sqqqMap = new Map(sqqqData.map(d => [d.date, d]));\n\n        const initialTQQQPrice = tqqqMap.get(qqqData[0]?.date)?.close || 1;\n        const benchmarkTQQQShares = this.initialCapital / initialTQQQPrice;\n\n\n        // Iterate over NDX data (the driver)\n        for (let i = 250; i < qqqData.length; i++) {\n            const date = qqqData[i].date;\n            const qqqSlice = qqqData.slice(0, i + 1);\n\n            // Get current prices for tradeable assets\n            const tqqqCandle = tqqqMap.get(date);\n            const sqqqCandle = sqqqMap.get(date);\n\n            if (!tqqqCandle || !sqqqCandle) continue; // Skip if missing data\n\n            const signal = this.strategyController.analyze(qqqSlice);\n\n            // Execute Signal\n            if (signal.action === 'BUY') {\n                const targetSymbol = signal.symbol; // TQQQ or SQQQ\n                const targetPrice = targetSymbol === 'TQQQ' ? tqqqCandle.close : sqqqCandle.close;\n\n                if (currentPosition && currentPosition.symbol !== targetSymbol) {\n                    // Close current\n                    const exitPrice = currentPosition.symbol === 'TQQQ' ? tqqqCandle.close : sqqqCandle.close;\n\n                    currentPosition.exitDate = date;\n                    currentPosition.exitPrice = exitPrice;\n                    currentPosition.pnl = (currentPosition.exitPrice - currentPosition.entryPrice) * currentPosition.shares;\n                    currentPosition.returnPct = ((currentPosition.exitPrice - currentPosition.entryPrice) / currentPosition.entryPrice) * 100;\n                    currentPosition.portfolioReturnPct = (currentPosition.returnPct * (currentPosition.positionSizePct || 0)) / 100;\n\n                    const entryTime = new Date(currentPosition.entryDate).getTime();\n                    const exitTime = new Date(date).getTime();\n                    currentPosition.daysHeld = Math.round((exitTime - entryTime) / (1000 * 60 * 60 * 24));\n\n                    cash += currentPosition.exitPrice * currentPosition.shares;\n                    trades.push(currentPosition);\n                    currentPosition = null;\n                    shares = 0;\n                }\n\n                if (!currentPosition) {\n                    // Open new position\n                    const totalEquityAtEntry = cash;\n                    const amountToInvest = cash;\n                    shares = Math.floor(amountToInvest / targetPrice);\n                    const actualInvestment = shares * targetPrice;\n                    cash -= actualInvestment;\n\n                    // Calculate position size percentage\n                    let positionSizePct = 100; // Default to 100%\n                    if (totalEquityAtEntry > 0 && actualInvestment > 0) {\n                        positionSizePct = (actualInvestment / totalEquityAtEntry) * 100;\n                    }\n\n                    currentPosition = {\n                        entryDate: date,\n                        symbol: targetSymbol,\n                        side: 'LONG',\n                        entryPrice: targetPrice,\n                        shares: shares,\n                        positionSizePct: positionSizePct\n                    };\n                }\n            }\n\n            // Calculate Equity\n            let positionValue = 0;\n            if (currentPosition) {\n                const currentPrice = currentPosition.symbol === 'TQQQ' ? tqqqCandle.close : sqqqCandle.close;\n                positionValue = currentPosition.shares * currentPrice;\n            }\n            const totalEquity = cash + positionValue;\n\n            // Benchmark Equity (NDX)\n            const benchmarkEquity = benchmarkShares * qqqData[i].close;\n\n            // Benchmark Equity (TQQQ)\n            const benchmarkTQQQEquity = benchmarkTQQQShares * tqqqCandle.close;\n\n            // Normalize to Percentage Change\n            const equityPct = ((totalEquity - this.initialCapital) / this.initialCapital) * 100;\n            const benchmarkPct = ((benchmarkEquity - this.initialCapital) / this.initialCapital) * 100;\n            const benchmarkTQQQPct = ((benchmarkTQQQEquity - this.initialCapital) / this.initialCapital) * 100;\n\n            equityCurve.push({ date, equity: equityPct, benchmark: benchmarkPct, benchmarkTQQQ: benchmarkTQQQPct });\n        }\n\n        // Close final position\n        if (currentPosition) {\n            const lastDate = qqqData[qqqData.length - 1].date;\n            const tqqqLast = tqqqMap.get(lastDate);\n            const sqqqLast = sqqqMap.get(lastDate);\n\n            if (tqqqLast && sqqqLast) {\n                const exitPrice = currentPosition.symbol === 'TQQQ' ? tqqqLast.close : sqqqLast.close;\n\n                currentPosition.exitDate = lastDate;\n                currentPosition.exitPrice = exitPrice;\n                currentPosition.pnl = (currentPosition.exitPrice - currentPosition.entryPrice) * currentPosition.shares;\n                currentPosition.returnPct = ((currentPosition.exitPrice - currentPosition.entryPrice) / currentPosition.entryPrice) * 100;\n                currentPosition.portfolioReturnPct = (currentPosition.returnPct * (currentPosition.positionSizePct || 0)) / 100;\n\n                const entryTime = new Date(currentPosition.entryDate).getTime();\n                const exitTime = new Date(lastDate).getTime();\n                currentPosition.daysHeld = Math.round((exitTime - entryTime) / (1000 * 60 * 60 * 24));\n\n                trades.push(currentPosition);\n            }\n        }\n\n        return {\n            trades,\n            equityCurve,\n            metrics: this.calculateMetrics(equityCurve, trades)\n        };\n    }\n\n    private calculateMetrics(equityCurve: { date: string; equity: number; benchmark: number; benchmarkTQQQ: number }[], trades: Trade[]) {\n        if (equityCurve.length === 0) {\n            const empty = { totalReturn: 0, cagr: 0, maxDrawdown: 0, sharpeRatio: 0 };\n            return {\n                ...empty,\n                avgTrades: { daily: 0, monthly: 0, annually: 0 },\n                winRate: { wins: 0, losses: 0, winPct: 0 },\n                avgPositionSize: 0,\n                benchmark: empty,\n                benchmarkTQQQ: empty\n            };\n        }\n\n        const strategyMetrics = this.getMetrics(equityCurve.map(d => ({ date: d.date, value: d.equity })));\n        const benchmarkMetrics = this.getMetrics(equityCurve.map(d => ({ date: d.date, value: d.benchmark })));\n        const benchmarkTQQQMetrics = this.getMetrics(equityCurve.map(d => ({ date: d.date, value: d.benchmarkTQQQ })));\n\n        const totalDays = equityCurve.length;\n        const years = totalDays / 252;\n        const months = years * 12;\n\n        const avgTrades = {\n            daily: totalDays > 0 ? trades.length / totalDays : 0,\n            monthly: months > 0 ? trades.length / months : 0,\n            annually: years > 0 ? trades.length / years : 0\n        };\n\n        // Calculate win/loss stats\n        const wins = trades.filter(t => (t.returnPct || 0) > 0).length;\n        const losses = trades.filter(t => (t.returnPct || 0) < 0).length;\n        const winRate = {\n            wins,\n            losses,\n            winPct: trades.length > 0 ? (wins / trades.length) * 100 : 0\n        };\n\n        // Calculate average position size\n        const avgPositionSize = trades.length > 0\n            ? trades.reduce((sum, t) => sum + (t.positionSizePct || 0), 0) / trades.length\n            : 0;\n\n        return {\n            ...strategyMetrics,\n            avgTrades,\n            winRate,\n            avgPositionSize,\n            benchmark: benchmarkMetrics,\n            benchmarkTQQQ: benchmarkTQQQMetrics\n        };\n    }\n\n    private getMetrics(data: { date: string; value: number }[]) {\n        if (data.length === 0) return { totalReturn: 0, cagr: 0, maxDrawdown: 0, sharpeRatio: 0 };\n\n        // Data is in percentage change (e.g., 0, 5.5, -2.1)\n        // Convert back to absolute multiplier for CAGR calculation\n        const startVal = 1 + (data[0].value / 100);\n        const endVal = 1 + (data[data.length - 1].value / 100);\n\n        const totalReturn = (endVal - startVal) / startVal;\n\n        const years = data.length / 252;\n        const cagr = years > 0 ? Math.pow(endVal / startVal, 1 / years) - 1 : 0;\n\n        let maxPeak = -Infinity;\n        let maxDd = 0;\n\n        // Drawdown calculation\n        for (const point of data) {\n            const currentEquity = 100 * (1 + point.value / 100);\n            if (currentEquity > maxPeak) maxPeak = currentEquity;\n            const dd = (maxPeak - currentEquity) / maxPeak;\n            if (dd > maxDd) maxDd = dd;\n        }\n\n        return {\n            totalReturn: totalReturn * 100,\n            cagr: cagr * 100,\n            maxDrawdown: maxDd * 100,\n            sharpeRatio: 0\n        };\n    }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 582, "column": 0}, "map": {"version":3,"sources":["file:///Users/jvila/WebstormProjects/alpalo-v2/src/app/api/backtest/route.ts"],"sourcesContent":["import { NextResponse } from 'next/server';\nimport { PolygonClient } from '@/lib/polygon/client';\nimport { BacktestEngine } from '@/lib/backtest/backtestEngine';\n\nexport async function POST(request: Request) {\n    try {\n        const { from, to } = await request.json();\n\n        if (!from || !to) {\n            return NextResponse.json({ error: 'Missing from or to date' }, { status: 400 });\n        }\n\n        const client = new PolygonClient();\n\n        // Fetch data concurrently\n        const [tqqqData, sqqqData, qqqData] = await Promise.all([\n            client.fetchAggregates('TQQQ', from, to),\n            client.fetchAggregates('SQQQ', from, to),\n            client.fetchAggregates('QQQ', from, to)\n        ]);\n\n        if (tqqqData.length === 0) {\n            return NextResponse.json({ error: 'No data available for TQQQ' }, { status: 404 });\n        }\n\n        // Run backtest\n        const engine = new BacktestEngine(10000);\n        const result = engine.run(qqqData, tqqqData, sqqqData);\n\n        return NextResponse.json(result);\n\n    } catch (error: unknown) {\n        console.error('Backtest error:', error);\n        const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n        return NextResponse.json({ error: errorMessage }, { status: 500 });\n    }\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;;;;AAEO,eAAe,KAAK,OAAgB;IACvC,IAAI;QACA,MAAM,EAAE,IAAI,EAAE,EAAE,EAAE,GAAG,MAAM,QAAQ,IAAI;QAEvC,IAAI,CAAC,QAAQ,CAAC,IAAI;YACd,OAAO,oLAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAA0B,GAAG;gBAAE,QAAQ;YAAI;QACjF;QAEA,MAAM,SAAS,IAAI,sLAAa;QAEhC,0BAA0B;QAC1B,MAAM,CAAC,UAAU,UAAU,QAAQ,GAAG,MAAM,QAAQ,GAAG,CAAC;YACpD,OAAO,eAAe,CAAC,QAAQ,MAAM;YACrC,OAAO,eAAe,CAAC,QAAQ,MAAM;YACrC,OAAO,eAAe,CAAC,OAAO,MAAM;SACvC;QAED,IAAI,SAAS,MAAM,KAAK,GAAG;YACvB,OAAO,oLAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAA6B,GAAG;gBAAE,QAAQ;YAAI;QACpF;QAEA,eAAe;QACf,MAAM,SAAS,IAAI,gMAAc,CAAC;QAClC,MAAM,SAAS,OAAO,GAAG,CAAC,SAAS,UAAU;QAE7C,OAAO,oLAAY,CAAC,IAAI,CAAC;IAE7B,EAAE,OAAO,OAAgB;QACrB,QAAQ,KAAK,CAAC,mBAAmB;QACjC,MAAM,eAAe,iBAAiB,QAAQ,MAAM,OAAO,GAAG;QAC9D,OAAO,oLAAY,CAAC,IAAI,CAAC;YAAE,OAAO;QAAa,GAAG;YAAE,QAAQ;QAAI;IACpE;AACJ"}}]
}